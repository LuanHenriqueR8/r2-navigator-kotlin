window["divinaPlayer"] =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/InteractionManager.js":
/*!***********************************!*\
  !*** ./src/InteractionManager.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return InteractionManager; });\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n// For detecting taps\nvar referencePercent = 0.3; // For kinetic (mobile) scroll\n\nvar velocityFactor = 10;\nvar timeConstant = 325;\n\nvar InteractionManager =\n/*#__PURE__*/\nfunction () {\n  function InteractionManager(player) {\n    _classCallCheck(this, InteractionManager);\n\n    this._player = player;\n    var mc = new Hammer(this._player._rootElement); // CHECK\n    // Tap detection\n\n    mc.on(\"tap\", this._handleTap.bind(this)); // Swipe detection\n\n    mc.get(\"swipe\").set({\n      direction: Hammer.DIRECTION_ALL,\n      velocity: 10\n    });\n    mc.on(\"swipeleft swiperight swipeup swipedown\", this._handleSwipe.bind(this)); // CHECK IF SWIPE AND SCROLL CAN WORK TOGETHER!\n    // Scroll detection\n\n    mc.get(\"pan\").set({\n      direction: Hammer.DIRECTION_ALL\n    });\n    mc.on(\"panleft panright panup pandown panend\", this._handleScroll.bind(this));\n\n    this._resetScroll();\n  }\n\n  _createClass(InteractionManager, [{\n    key: \"_handleTap\",\n    value: function _handleTap(e) {\n      var story = this._player.story;\n\n      if (!story) {\n        return;\n      }\n\n      var readingDirection = story.readingDirection; // CHECK\n\n      var _e$center = e.center,\n          x = _e$center.x,\n          y = _e$center.y;\n      var _this$_player = this._player,\n          size = _this$_player.size,\n          viewportSize = _this$_player.viewportSize;\n      var width = viewportSize.width,\n          height = viewportSize.height;\n      var referenceXLength = (size.width - width) / 2 + width * referencePercent;\n      var referenceYLength = (size.height - height) / 2 + height * referencePercent;\n\n      switch (readingDirection) {\n        case \"ltr\":\n          if (x >= size.width - referenceXLength) {\n            story.goForward();\n          } else if (x <= referenceXLength) {\n            story.goBackward();\n          }\n\n          break;\n\n        case \"rtl\":\n          if (x <= referenceXLength) {\n            story.goForward();\n          } else if (x >= size.width - referenceXLength) {\n            story.goBackward();\n          }\n\n          break;\n\n        case \"ttb\":\n          if (y >= size.height - referenceYLength) {\n            story.goForward();\n          } else if (y <= referenceYLength) {\n            story.goBackward();\n          }\n\n          break;\n\n        case \"btt\":\n          if (y <= referenceYLength) {\n            story.goForward();\n          } else if (y >= size.height - referenceYLength) {\n            story.goBackward();\n          }\n\n          break;\n\n        default:\n          break;\n      }\n    }\n  }, {\n    key: \"_handleSwipe\",\n    value: function _handleSwipe(e) {\n      var story = this._player.story;\n\n      if (!story) {\n        return;\n      }\n\n      var readingDirection = story.readingDirection; // CHECK\n\n      console.log(e.type);\n\n      switch (readingDirection) {\n        case \"ltr\":\n          if (e.type === \"swipeleft\") {\n            story.goForward();\n          } else if (e.type === \"swiperight\") {\n            story.goBackward();\n          }\n\n          break;\n\n        case \"rtl\":\n          if (e.type === \"swiperight\") {\n            story.goForward();\n          } else if (e.type === \"swipeleft\") {\n            story.goBackward();\n          }\n\n          break;\n\n        case \"ttb\":\n          if (e.type === \"swipeup\") {\n            story.goForward();\n          } else if (e.type === \"swipedown\") {\n            story.goBackward();\n          }\n\n          break;\n\n        case \"btt\":\n          if (e.type === \"swipedown\") {\n            story.goForward();\n          } else if (e.type === \"swipeup\") {\n            story.goBackward();\n          }\n\n          break;\n\n        default:\n          break;\n      }\n    }\n  }, {\n    key: \"_resetScroll\",\n    value: function _resetScroll() {\n      this._lastScrollEvent = {\n        deltaX: 0,\n        deltaY: 0\n      };\n    }\n  }, {\n    key: \"_handleScroll\",\n    value: function _handleScroll(e) {\n      if (e.type === \"panend\") {\n        this._releaseScroll(e);\n\n        this._resetScroll();\n      } else if (this._lastScrollEvent) {\n        var absEvent = {\n          deltaX: this._lastScrollEvent.deltaX - e.deltaX,\n          deltaY: this._lastScrollEvent.deltaY - e.deltaY\n        };\n\n        this._scroll(absEvent);\n\n        this._lastScrollEvent = e;\n      }\n    }\n  }, {\n    key: \"_releaseScroll\",\n    value: function _releaseScroll(e) {\n      if (!this._player.story) {\n        return;\n      }\n\n      var velocity = {\n        x: e.velocityX * velocityFactor,\n        y: e.velocityY * velocityFactor\n      };\n      var releaseTime = Date.now(); //this._player.story.setKineticScrollData({ velocity, releaseTime, timeConstant })\n    }\n  }, {\n    key: \"_scroll\",\n    value: function _scroll(e) {\n      if (!this._player.story) {\n        return;\n      }\n\n      this._player.story.setScrollDelta({\n        deltaX: e.deltaX,\n        deltaY: e.deltaY\n      });\n    }\n  }]);\n\n  return InteractionManager;\n}();\n\n\n\n//# sourceURL=webpack://divinaPlayer/./src/InteractionManager.js?");

/***/ }),

/***/ "./src/LayerSlice.js":
/*!***************************!*\
  !*** ./src/LayerSlice.js ***!
  \***************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return LayerSlice; });\n/* harmony import */ var _Slice_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Slice.js */ \"./src/Slice.js\");\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\n\nvar LayerSlice =\n/*#__PURE__*/\nfunction (_Slice) {\n  _inherits(LayerSlice, _Slice);\n\n  _createClass(LayerSlice, [{\n    key: \"isLayer\",\n    get: function get() {\n      return this._isLayer;\n    }\n  }, {\n    key: \"speed\",\n    get: function get() {\n      return this._speed;\n    }\n  }]);\n\n  function LayerSlice(href, speed, fit, player) {\n    var _this;\n\n    _classCallCheck(this, LayerSlice);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(LayerSlice).call(this, href, fit, player));\n    _this._isLayer = true;\n    _this._speed = speed;\n    return _this;\n  }\n\n  return LayerSlice;\n}(_Slice_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n\n\n//# sourceURL=webpack://divinaPlayer/./src/LayerSlice.js?");

/***/ }),

/***/ "./src/Page.js":
/*!*********************!*\
  !*** ./src/Page.js ***!
  \*********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Page; });\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar Page =\n/*#__PURE__*/\nfunction () {\n  _createClass(Page, [{\n    key: \"overflow\",\n    get: function get() {\n      return this._overflow;\n    }\n  }, {\n    key: \"progress\",\n    get: function get() {\n      return this._progress;\n    }\n  }, {\n    key: \"slicesArray\",\n    get: function get() {\n      return this._slicesArray;\n    }\n  }]);\n\n  function Page(player, readingDirection, overflow) {\n    _classCallCheck(this, Page);\n\n    this._player = player;\n    this._readingDirection = readingDirection;\n    this._overflow = overflow;\n    this._progress = null;\n    this._slicesArray = [];\n    this._pageContainer = new PIXI.Container();\n    this._snapPointsArray = [];\n    this._firstFit = null;\n  }\n\n  _createClass(Page, [{\n    key: \"addSlice\",\n    value: function addSlice(slice) {\n      this._slicesArray.push(slice);\n\n      if (!this._firstFit) {\n        this._firstFit = slice.fit;\n      }\n    }\n  }, {\n    key: \"addSnapPoints\",\n    value: function addSnapPoints(snapPointsArray) {\n      var _this = this;\n\n      if (!snapPointsArray) {\n        return;\n      }\n\n      snapPointsArray.forEach(function (snapPointInfo) {\n        var type = snapPointInfo.type,\n            x = snapPointInfo.x,\n            y = snapPointInfo.y;\n        var snapPoint = {\n          sliceIndex: _this._slicesArray.length - 1,\n          type: type,\n          x: x,\n          y: y\n        };\n\n        _this._snapPointsArray.push(snapPoint);\n      });\n    }\n  }, {\n    key: \"finishBuilding\",\n    value: function finishBuilding() {\n      var _this2 = this;\n\n      this._slicesArray.forEach(function (slice) {\n        slice.build();\n\n        if (slice.layerSlicesArray.length === 0) {\n          slice.addSpriteToContainer(_this2._pageContainer);\n        } else {\n          slice.layerSlicesArray.forEach(function (layerSlice) {\n            layerSlice.build();\n            layerSlice.addSpriteToContainer(_this2._pageContainer);\n          });\n        }\n      });\n\n      if (this._snapPointsArray.length > 0) {\n        this._relativeStart = null; // Start point in relative coordinates (from top left)\n\n        this._relativeEnd = null; // End point in relative coordinates (from top left)\n\n        switch (this._readingDirection) {\n          case \"ltr\":\n            this._relativeStart = {\n              x: 0,\n              y: 0.5 // Start is furthest left\n\n            };\n            this._relativeEnd = {\n              x: 1,\n              y: 0.5 // End is furthest right\n\n            };\n            break;\n\n          case \"rtl\":\n            this._relativeStart = {\n              x: 1,\n              y: 0.5\n            };\n            this._relativeEnd = {\n              x: 0,\n              y: 0.5\n            };\n            break;\n\n          case \"ttb\":\n            this._relativeStart = {\n              x: 0.5,\n              y: 0\n            };\n            this._relativeEnd = {\n              x: 0.5,\n              y: 1\n            };\n            break;\n\n          case \"btt\":\n            this._relativeStart = {\n              x: 0.5,\n              y: 1\n            };\n            this._relativeEnd = {\n              x: 0.5,\n              y: 0\n            };\n            break;\n\n          default:\n            break;\n        }\n      }\n\n      if (this._overflow !== \"paginated\") {\n        this._positionSlices();\n      }\n    }\n  }, {\n    key: \"populateContainer\",\n    value: function populateContainer(container) {\n      container.addChild(this._pageContainer);\n    } // Keep slice centered if paginated\n    // Or in 2 other flow types if doesn't cover the viewport AND no image after it... \n\n  }, {\n    key: \"_positionSlices\",\n    value: function _positionSlices() {\n      var _this3 = this;\n\n      var sliceOffset = 0;\n\n      this._slicesArray.forEach(function (slice, i) {\n        var _slice$size = slice.size,\n            width = _slice$size.width,\n            height = _slice$size.height;\n\n        switch (_this3._readingDirection) {\n          case \"ltr\":\n            slice.offset = {\n              x: sliceOffset,\n              y: 0\n            };\n            slice.sprite.position.x = sliceOffset + width / 2;\n            sliceOffset += width;\n            break;\n\n          case \"rtl\":\n            slice.offset = {\n              x: sliceOffset,\n              y: 0\n            };\n            slice.sprite.position.x = sliceOffset - width / 2;\n            sliceOffset -= width;\n            break;\n\n          case \"ttb\":\n            slice.offset = {\n              x: 0,\n              y: sliceOffset\n            };\n            slice.sprite.position.y = sliceOffset + height / 2;\n            sliceOffset += height;\n            break;\n\n          case \"btt\":\n            slice.offset = {\n              x: 0,\n              y: sliceOffset\n            };\n            slice.sprite.position.y = sliceOffset - height / 2;\n            sliceOffset -= height;\n            break;\n\n          default:\n            break;\n        }\n\n        if (slice.layerSlicesArray.length > 0) {\n          slice.setStartPosition();\n          /*slice.layerSlicesArray.forEach((layerSlice) => {\n          \tlayerSlice.sprite.position = slice.startPosition\n          })*/\n          // Layer slices are not positioned correctly when not large enough!\n          // And also when not the same size as the underlying (fallback) image...\t\t\t\t\n        }\n      });\n\n      this._startPosition = {\n        x: 0,\n        y: 0\n      };\n      this._endPosition = {\n        x: 0,\n        y: 0\n      };\n      var totalDistanceToCover = sliceOffset;\n      var _this$_player$viewpor = this._player.viewportSize,\n          width = _this$_player$viewpor.width,\n          height = _this$_player$viewpor.height;\n\n      switch (this._readingDirection) {\n        case \"ltr\":\n          totalDistanceToCover -= width;\n\n          if (totalDistanceToCover <= 0) {\n            this._pageContainer.position.x = -totalDistanceToCover / 2 - width / 2;\n          } else {\n            this._startPosition.x = -width / 2;\n            this._endPosition.x = -totalDistanceToCover - width / 2;\n          }\n\n          break;\n\n        case \"rtl\":\n          totalDistanceToCover += width;\n\n          if (totalDistanceToCover >= 0) {\n            this._pageContainer.position.x = -totalDistanceToCover / 2 + width / 2;\n          } else {\n            this._startPosition.x = width / 2;\n            this._endPosition.x = -totalDistanceToCover + width / 2;\n          }\n\n          break;\n\n        case \"ttb\":\n          totalDistanceToCover -= height;\n\n          if (totalDistanceToCover <= 0) {\n            this._pageContainer.position.x = -totalDistanceToCover / 2 - height / 2;\n          } else {\n            this._startPosition.y = -height / 2;\n            this._endPosition.y = -totalDistanceToCover - height / 2;\n          }\n\n          break;\n\n        case \"btt\":\n          totalDistanceToCover += height;\n\n          if (totalDistanceToCover >= 0) {\n            this._pageContainer.position.x = -totalDistanceToCover / 2 + height / 2;\n          } else {\n            this._startPosition.y = -height / 2;\n            this._endPosition.y = -totalDistanceToCover + height / 2;\n          }\n\n          break;\n\n        default:\n          break;\n      }\n\n      this._buildSnapPoints();\n    }\n  }, {\n    key: \"_buildSnapPoints\",\n    value: function _buildSnapPoints() {\n      var _this4 = this;\n\n      if (this._snapPointsArray.length <= 0) {\n        return;\n      }\n\n      this._snapPointsArray.forEach(function (snapPoint) {\n        var progress = _this4._getProgressForSnapPoint(snapPoint);\n\n        snapPoint.progress = progress;\n      });\n    }\n  }, {\n    key: \"_getProgressForSnapPoint\",\n    value: function _getProgressForSnapPoint(snapPoint) {\n      var sliceIndex = snapPoint.sliceIndex,\n          type = snapPoint.type,\n          x = snapPoint.x,\n          y = snapPoint.y;\n      var slice = this._slicesArray[sliceIndex];\n      var size = slice.size,\n          offset = slice.offset;\n\n      var absoluteCenter = this._getAbsoluteCenter(type, {\n        x: x,\n        y: y\n      }, size);\n\n      absoluteCenter.x -= offset.x;\n      absoluteCenter.y -= offset.y;\n\n      var distanceToCenter = this._getDistance(this._startPosition, absoluteCenter);\n\n      var totalDistanceToCover = this._getDistance(this._startPosition, this._endPosition);\n\n      var progress = Math.min(Math.max(Math.abs(distanceToCenter / totalDistanceToCover), 0), 1);\n      return progress;\n    }\n  }, {\n    key: \"_getAbsoluteCenter\",\n    value: function _getAbsoluteCenter(type, _ref, _ref2) {\n      var x = _ref.x,\n          y = _ref.y;\n      var width = _ref2.width,\n          height = _ref2.height;\n      var viewportSize = this._player.viewportSize;\n      var sign = this._readingDirection === \"ltr\" || this._readingDirection === \"ttb\" ? -1 : 1;\n      var center;\n\n      switch (type) {\n        case \"start\":\n          center = {\n            x: sign * (x || 0) * width + (this._relativeStart.x - 0.5) * viewportSize.width,\n            y: sign * (y || 0) * height + (this._relativeStart.y - 0.5) * viewportSize.height\n          };\n          break;\n\n        case \"end\":\n          center = {\n            x: sign * (x || 0) * width + (this._relativeEnd.x - 0.5) * viewportSize.width,\n            y: sign * (y || 0) * height + (this._relativeEnd.y - 0.5) * viewportSize.height\n          };\n          break;\n\n        default:\n          // \"center\"\n          center = {\n            x: sign * (x || 0) * width,\n            y: sign * (y || 0) * height\n          };\n          break;\n      }\n\n      return center;\n    }\n  }, {\n    key: \"_getDistance\",\n    value: function _getDistance(point1, point2) {\n      return Math.sqrt(Math.pow(point2.x - point1.x, 2) + Math.pow(point2.y - point1.y, 2));\n    }\n  }, {\n    key: \"getProgressForSliceIndex\",\n    value: function getProgressForSliceIndex(sliceIndex) {\n      var type = \"start\";\n      var x;\n      var y;\n\n      if (this._readingDirection === \"ltr\" || this._readingDirection === \"rtl\") {\n        x = 0;\n      }\n\n      if (this._readingDirection === \"ttb\" || this._readingDirection === \"btt\") {\n        y = 0;\n      }\n\n      var snapPoint = {\n        sliceIndex: sliceIndex,\n        type: type,\n        x: x,\n        y: y\n      };\n\n      var progress = this._getProgressForSnapPoint(snapPoint);\n\n      return progress;\n    }\n  }, {\n    key: \"setProgress\",\n    value: function setProgress(p) {\n      this._progress = p;\n      var vector = {\n        x: this._endPosition.x - this._startPosition.x,\n        y: this._endPosition.y - this._startPosition.y\n      };\n      this._pageContainer.position.x = this._startPosition.x + p * vector.x;\n      this._pageContainer.position.y = this._startPosition.y + p * vector.y;\n\n      this._slicesArray.forEach(function (slice) {\n        var startPosition = slice.startPosition;\n        slice.layerSlicesArray.forEach(function (layerSlice) {\n          var sprite = layerSlice.sprite,\n              speed = layerSlice.speed;\n          sprite.position.x = startPosition.x + (speed - 1) * p * vector.x;\n          sprite.position.y = startPosition.y + (speed - 1) * p * vector.y;\n        });\n      });\n    }\n  }, {\n    key: \"applyScrollDelta\",\n    value: function applyScrollDelta(scrollDelta) {\n      var deltaX = scrollDelta.deltaX,\n          deltaY = scrollDelta.deltaY;\n      var progress = this._progress;\n      var xDistanceToCover = this._endPosition.x - this._startPosition.x;\n\n      if (xDistanceToCover > 0) {\n        var xPosition = Math.min(Math.max(this._pageContainer.position.x - deltaX, this._startPosition.x), this._startPosition.x + xDistanceToCover);\n        progress = Math.abs((xPosition - this._startPosition.x) / xDistanceToCover);\n      } else if (xDistanceToCover < 0) {\n        var _xPosition = Math.min(Math.max(this._pageContainer.position.x - deltaX, this._startPosition.x + xDistanceToCover), this._startPosition.x);\n\n        progress = Math.abs((_xPosition - this._startPosition.x) / xDistanceToCover);\n      }\n\n      var yDistanceToCover = this._endPosition.y - this._startPosition.y;\n\n      if (yDistanceToCover > 0) {\n        var yPosition = Math.min(Math.max(this._pageContainer.position.y - deltaY, this._startPosition.y), this._startPosition.y + yDistanceToCover);\n        progress = Math.abs((yPosition - this._startPosition.y) / yDistanceToCover);\n      } else if (yDistanceToCover < 0) {\n        var _yPosition = Math.min(Math.max(this._pageContainer.position.y - deltaY, this._startPosition.y + yDistanceToCover), this._startPosition.y);\n\n        progress = Math.abs((_yPosition - this._startPosition.y) / yDistanceToCover);\n      }\n\n      this.setProgress(progress);\n    }\n  }, {\n    key: \"goToNextSnapPoint\",\n    value: function goToNextSnapPoint() {\n      var i = 0;\n\n      while (i < this._snapPointsArray.length && this._snapPointsArray[i].progress <= this._progress) {\n        i += 1;\n      }\n\n      if (i < this._snapPointsArray.length) {\n        this.setProgress(this._snapPointsArray[i].progress);\n      }\n    }\n  }, {\n    key: \"goToPreviousSnapPoint\",\n    value: function goToPreviousSnapPoint() {\n      var i = this._snapPointsArray.length - 1; // BEWARE!!!\n\n      while (i >= 0 && this._snapPointsArray[i].progress >= this._progress) {\n        i -= 1;\n      }\n\n      if (i >= 0) {\n        this.setProgress(this._snapPointsArray[i].progress);\n      }\n    }\n  }, {\n    key: \"resize\",\n    value: function resize() {\n      this._slicesArray.forEach(function (slice) {\n        slice.applyFit();\n        slice.layerSlicesArray.forEach(function (layerSlice) {\n          layerSlice.applyFit();\n        });\n      });\n\n      if (this._overflow !== \"paginated\") {\n        this._positionSlices();\n\n        if (this._progress !== null) {\n          this.setProgress(this._progress);\n        }\n      }\n    }\n  }]);\n\n  return Page;\n}();\n\n\n\n//# sourceURL=webpack://divinaPlayer/./src/Page.js?");

/***/ }),

/***/ "./src/Player.js":
/*!***********************!*\
  !*** ./src/Player.js ***!
  \***********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Player; });\n/* harmony import */ var _InteractionManager_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./InteractionManager.js */ \"./src/InteractionManager.js\");\n/* harmony import */ var _Story_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Story.js */ \"./src/Story.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\nvar defaultBackgroundColor = 0x000000;\n\nvar Player =\n/*#__PURE__*/\nfunction () {\n  _createClass(Player, [{\n    key: \"size\",\n    get: function get() {\n      var _this$_app$renderer = this._app.renderer,\n          width = _this$_app$renderer.width,\n          height = _this$_app$renderer.height;\n      return {\n        width: width,\n        height: height\n      };\n    }\n  }, {\n    key: \"viewportSize\",\n    get: function get() {\n      return this._viewportSize;\n    }\n  }, {\n    key: \"story\",\n    get: function get() {\n      return this._story;\n    }\n  }, {\n    key: \"contentContainer\",\n    get: function get() {\n      return this._contentContainer;\n    }\n  }, {\n    key: \"mask\",\n    get: function get() {\n      return this._mask;\n    }\n  }]);\n\n  function Player(rootElement) {\n    _classCallCheck(this, Player);\n\n    this._rootElement = rootElement;\n    this._app = new PIXI.Application({\n      backgroundColor: defaultBackgroundColor\n    }); // Creation of the default containers\n\n    this._app.stage.name = \"appContainer\";\n\n    this._rootElement.appendChild(this._app.view);\n\n    this._rootContainer = new PIXI.Container();\n    this._rootContainer.name = \"rootContainer\"; // Will be used to hold the viewport, simulating bar scopes with a mask\n\n    this._app.stage.addChild(this._rootContainer);\n\n    this._contentContainer = new PIXI.Container();\n    this._contentContainer.name = \"contentContainer\"; // The container that is scaled to express fit\n\n    this._rootContainer.addChild(this._contentContainer);\n\n    this._mask = new PIXI.Graphics(); // Initial sizing\n\n    this.resize(); // Interactions\n\n    this._rootContainer.interactive = true;\n    this._interactionManager = new _InteractionManager_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](this); // Story\n\n    this._story = null;\n    this._ratioConstraint = null;\n  }\n\n  _createClass(Player, [{\n    key: \"resize\",\n    value: function resize() {\n      // On creating player and then on any resize call (after an orientation change)\n      var _this$_rootElement$ge = this._rootElement.getBoundingClientRect(),\n          width = _this$_rootElement$ge.width,\n          height = _this$_rootElement$ge.height;\n\n      this._app.renderer.resize(width, height);\n\n      this._sizeViewport(width, height);\n\n      if (this._story) {\n        this._story.resize();\n      }\n    }\n  }, {\n    key: \"_sizeViewport\",\n    value: function _sizeViewport(width, height) {\n      var windowRatio = width / height;\n      var viewportWidth = width;\n      var viewportHeight = height;\n\n      var applicableRatio = this._getApplicableRatio(width, height);\n\n      if (windowRatio > applicableRatio) {\n        viewportWidth = height * applicableRatio;\n      } else if (windowRatio < applicableRatio) {\n        viewportHeight = width / applicableRatio;\n      }\n\n      this._viewportSize = {\n        width: viewportWidth,\n        height: viewportHeight // Position contentContainer's pivot to allow for default centering\n\n      };\n      this._contentContainer.pivot = {\n        x: -width / 2,\n        y: -height / 2 // Apply mask to only show viewport area\n\n      };\n\n      this._mask.clear();\n\n      this._mask.beginFill(0x0000FF);\n\n      this._mask.drawRect((width - viewportWidth) / 2, (height - viewportHeight) / 2, viewportWidth, viewportHeight);\n\n      this._mask.endFill();\n\n      this._rootContainer.mask = this._mask;\n    } // _ratioConstraint.value written as width / height, e.g. \"3:4\" for a \"4:3\" in portrait mode\n\n  }, {\n    key: \"_getApplicableRatio\",\n    value: function _getApplicableRatio(width, height) {\n      var applicableRatio = width / height;\n\n      if (!this._ratioConstraint) {\n        return applicableRatio;\n      }\n\n      var _this$_ratioConstrain = this._ratioConstraint,\n          type = _this$_ratioConstrain.type,\n          value = _this$_ratioConstrain.value;\n\n      if (!type || !value) {\n        return applicableRatio;\n      }\n\n      var valueParts = value.split(\":\");\n\n      if (valueParts.length !== 2) {\n        return applicableRatio;\n      }\n\n      var ratioConstraintWidth = valueParts[0];\n      var ratioConstraintHeight = valueParts[1];\n\n      if (isNaN(ratioConstraintWidth) === true || isNaN(ratioConstraintHeight) === true) {\n        return applicableRatio;\n      }\n\n      var ratio = ratioConstraintWidth / ratioConstraintHeight;\n\n      switch (type) {\n        case \"min\":\n          applicableRatio = Math.max(ratio, applicableRatio);\n          break;\n\n        case \"max\":\n          applicableRatio = Math.min(ratio, applicableRatio);\n          break;\n\n        case \"exact\":\n          applicableRatio = ratio;\n          break;\n\n        default:\n          break;\n      }\n\n      return applicableRatio;\n    }\n  }, {\n    key: \"setRatioConstraint\",\n    value: function setRatioConstraint(ratioConstraint) {\n      this._ratioConstraint = ratioConstraint;\n      this.resize();\n    } // Load story\n\n  }, {\n    key: \"openDiViNaFromPath\",\n    value: function openDiViNaFromPath(folderPath) {\n      this._createStory();\n\n      this._story.loadFromPath(folderPath);\n    }\n  }, {\n    key: \"openDiViNaFromJSON\",\n    value: function openDiViNaFromJSON(json) {\n      this._createStory();\n\n      this._story.loadFromJSON(json);\n    }\n  }, {\n    key: \"_createStory\",\n    value: function _createStory() {\n      PIXI.Loader.shared.reset();\n      this._story = new _Story_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](this);\n    }\n  }, {\n    key: \"goTo\",\n    value: function goTo(href) {\n      if (this._story) {\n        this._story.goTo(href);\n      }\n    } // FOR EXITING\n\n  }, {\n    key: \"kill\",\n    value: function kill() {\n      if (this._story) {//this._story.kill()\n        // Remove eventListeners in InteractionManager?\n      }\n\n      this._app.destroy();\n    }\n    /*setProgress(progress) {\n    \tif (this._story) {\n    \t\tthis._story.setProgress(progress)\n    \t}\n    }*/\n\n  }]);\n\n  return Player;\n}();\n\n\n\n//# sourceURL=webpack://divinaPlayer/./src/Player.js?");

/***/ }),

/***/ "./src/ResourceManager.js":
/*!********************************!*\
  !*** ./src/ResourceManager.js ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return ResourceManager; });\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar ResourceManager =\n/*#__PURE__*/\nfunction () {\n  function ResourceManager(folderPath) {\n    _classCallCheck(this, ResourceManager);\n\n    this._folderPath = folderPath;\n  }\n\n  _createClass(ResourceManager, [{\n    key: \"addResource\",\n    value: function addResource(href) {\n      var resourcePath = href.split(\"#\")[0];\n\n      if (PIXI.Loader.shared.resources[resourcePath]) {\n        return;\n      }\n\n      PIXI.Loader.shared.add(resourcePath, this._folderPath + \"/\" + resourcePath);\n    }\n  }, {\n    key: \"loadAllResources\",\n    value: function loadAllResources() {\n      return new Promise(function (resolve, reject) {\n        PIXI.Loader.shared.load(function (loader, resources) {\n          resolve();\n        });\n      });\n    }\n  }]);\n\n  return ResourceManager;\n}();\n\n\n\n//# sourceURL=webpack://divinaPlayer/./src/ResourceManager.js?");

/***/ }),

/***/ "./src/SequenceSlice.js":
/*!******************************!*\
  !*** ./src/SequenceSlice.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return SequenceSlice; });\n/* harmony import */ var _Slice_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Slice.js */ \"./src/Slice.js\");\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\n\nvar SequenceSlice =\n/*#__PURE__*/\nfunction (_Slice) {\n  _inherits(SequenceSlice, _Slice);\n\n  function SequenceSlice(linkObjectsArray, duration, fit, player) {\n    var _this;\n\n    _classCallCheck(this, SequenceSlice);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(SequenceSlice).call(this, null, fit, player));\n    _this._linkObjectsArray = linkObjectsArray;\n    _this._duration = duration;\n\n    if (_this._linkObjectsArray && _this._linkObjectsArray.length >= 0) {\n      var firstLinkObject = _this._linkObjectsArray[0];\n\n      if (firstLinkObject.fit) {\n        _this._fit = firstLinkObject.fit;\n      }\n    }\n\n    return _this;\n  }\n\n  _createClass(SequenceSlice, [{\n    key: \"_createSprite\",\n    value: function _createSprite() {\n      var _this2 = this;\n\n      var texturesArray = [];\n      var time = this._duration / this._linkObjectsArray.length;\n\n      this._linkObjectsArray.forEach(function (linkObject) {\n        var texture = _this2._getTextureForHref(linkObject.href);\n\n        texturesArray.push({\n          texture: texture,\n          time: time\n        });\n      });\n\n      var sprite = new PIXI.AnimatedSprite(texturesArray);\n      sprite.loop = false;\n      return sprite;\n    } // When fit is applied, do note that the considered natural dimensions are that of the first frame...\n    // Meaning the scale will be the one computed for the first frame\n    // So if the sizes of the frames are not all equal... well that's definitely an issue!\n\n  }]);\n\n  return SequenceSlice;\n}(_Slice_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n\n\n//# sourceURL=webpack://divinaPlayer/./src/SequenceSlice.js?");

/***/ }),

/***/ "./src/Slice.js":
/*!**********************!*\
  !*** ./src/Slice.js ***!
  \**********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Slice; });\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar Slice =\n/*#__PURE__*/\nfunction () {\n  _createClass(Slice, [{\n    key: \"size\",\n    get: function get() {\n      return {\n        width: this._naturalWidth * this._scale,\n        height: this._naturalHeight * this._scale\n      };\n    }\n  }, {\n    key: \"href\",\n    get: function get() {\n      return this._href;\n    }\n  }, {\n    key: \"fit\",\n    get: function get() {\n      return this._fit;\n    }\n  }, {\n    key: \"sprite\",\n    get: function get() {\n      return this._sprite;\n    }\n  }, {\n    key: \"layerSlicesArray\",\n    get: function get() {\n      return this._layerSlicesArray;\n    }\n  }, {\n    key: \"startPosition\",\n    get: function get() {\n      return this._startPosition;\n    }\n  }]);\n\n  function Slice(href, fit, player) {\n    _classCallCheck(this, Slice);\n\n    if (href) {\n      this._href = href;\n    }\n\n    this._fit = fit;\n    this._player = player;\n    this._layerSlicesArray = [];\n  }\n\n  _createClass(Slice, [{\n    key: \"addLayerSlice\",\n    value: function addLayerSlice(layerSlice) {\n      this._layerSlicesArray.push(layerSlice);\n    }\n  }, {\n    key: \"build\",\n    value: function build() {\n      this._sprite = this._createSprite();\n\n      this._sprite.anchor.set(0.5);\n\n      this._naturalWidth = this._sprite.width;\n      this._naturalHeight = this._sprite.height;\n      this.applyFit();\n    }\n  }, {\n    key: \"_createSprite\",\n    value: function _createSprite() {\n      var texture = this._getTextureForHref(this._href);\n\n      var sprite = new PIXI.Sprite(texture);\n      return sprite;\n    }\n  }, {\n    key: \"_getTextureForHref\",\n    value: function _getTextureForHref(href) {\n      var hrefParts = href.split(\"#\");\n      var resourcePath = hrefParts[0];\n      var texture = PIXI.Loader.shared.resources[resourcePath].texture;\n\n      if (hrefParts.length === 2) {\n        var percentOrPixel = \"pixel\";\n        var fragmentInfo = hrefParts[1].split(\"=\")[1];\n        var xywh = fragmentInfo;\n        fragmentInfo = fragmentInfo.split(\":\");\n\n        if (fragmentInfo.length === 2) {\n          percentOrPixel = fragmentInfo[0];\n          xywh = fragmentInfo[1];\n        }\n\n        var xywhArray = xywh.split(\",\");\n        var x = Number(xywhArray[0]);\n        var y = Number(xywhArray[1]);\n        var w = Number(xywhArray[2]);\n        var h = Number(xywhArray[3]);\n        var width = texture.width,\n            height = texture.height;\n\n        if (percentOrPixel === \"percent\") {\n          x *= width / 100;\n          y *= height / 100;\n          w *= width / 100;\n          h *= height / 100;\n        }\n\n        var baseTexture = texture.baseTexture;\n        var frame = new PIXI.Rectangle(x, y, w, h);\n        var framedTexture = new PIXI.Texture(baseTexture, frame);\n        return framedTexture;\n      } // Note that fit will apply to the fragment, not the entire uncropped resource!\n\n\n      return texture;\n    }\n  }, {\n    key: \"addSpriteToContainer\",\n    value: function addSpriteToContainer(container) {\n      container.addChild(this._sprite);\n    }\n  }, {\n    key: \"applyFit\",\n    value: function applyFit() {\n      var naturalRatio = this._naturalWidth / this._naturalHeight;\n      var _this$_player$viewpor = this._player.viewportSize,\n          width = _this$_player$viewpor.width,\n          height = _this$_player$viewpor.height;\n      var ratio = width / height;\n      var scale = 1;\n\n      switch (this._fit) {\n        case \"height\":\n          scale = this._getScaleWhenForcingHeight(height, this._naturalHeight);\n          break;\n\n        case \"width\":\n          scale = this._getScaleWhenForcingWidth(width, this._naturalWidth);\n          break;\n\n        case \"contain\":\n          if (naturalRatio >= ratio) {\n            scale = this._getScaleWhenForcingWidth(width, this._naturalWidth);\n          } else {\n            scale = this._getScaleWhenForcingHeight(height, this._naturalHeight);\n          }\n\n          break;\n\n        case \"cover\":\n          if (naturalRatio >= ratio) {\n            scale = this._getScaleWhenForcingHeight(height, this._naturalHeight);\n          } else {\n            scale = this._getScaleWhenForcingWidth(width, this._naturalWidth);\n          }\n\n          break;\n\n        default:\n          break;\n      }\n\n      this._sprite.scale.set(scale);\n\n      this._scale = scale;\n    }\n  }, {\n    key: \"_getScaleWhenForcingHeight\",\n    value: function _getScaleWhenForcingHeight(viewportHeight, resourceHeight) {\n      var scale = viewportHeight / resourceHeight;\n      return scale;\n    }\n  }, {\n    key: \"_getScaleWhenForcingWidth\",\n    value: function _getScaleWhenForcingWidth(viewportWidth, resourceWidth) {\n      var scale = viewportWidth / resourceWidth;\n      return scale;\n    }\n  }, {\n    key: \"setStartPosition\",\n    value: function setStartPosition() {\n      this._startPosition = {\n        x: this._sprite.position.x,\n        y: this._sprite.position.y\n      };\n    }\n  }]);\n\n  return Slice;\n}();\n\n\n\n//# sourceURL=webpack://divinaPlayer/./src/Slice.js?");

/***/ }),

/***/ "./src/Story.js":
/*!**********************!*\
  !*** ./src/Story.js ***!
  \**********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Story; });\n/* harmony import */ var _Page_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Page.js */ \"./src/Page.js\");\n/* harmony import */ var _Slice_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Slice.js */ \"./src/Slice.js\");\n/* harmony import */ var _LayerSlice_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./LayerSlice.js */ \"./src/LayerSlice.js\");\n/* harmony import */ var _SequenceSlice_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./SequenceSlice.js */ \"./src/SequenceSlice.js\");\n/* harmony import */ var _ResourceManager_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ResourceManager.js */ \"./src/ResourceManager.js\");\n/* harmony import */ var _TransitionManager_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./TransitionManager.js */ \"./src/TransitionManager.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\n\n\n\nvar defaultManifestFilename = \"publication.json\";\n\nvar Story =\n/*#__PURE__*/\nfunction () {\n  _createClass(Story, [{\n    key: \"readingDirection\",\n    get: function get() {\n      return this._readingDirection;\n    }\n  }]);\n\n  function Story(player) {\n    _classCallCheck(this, Story);\n\n    this._player = player;\n    this._pagesArray = [];\n    this._transitionManager = null;\n  }\n\n  _createClass(Story, [{\n    key: \"loadFromPath\",\n    value: function loadFromPath(folderPath) {\n      var _this = this;\n\n      this._resourceManager = new _ResourceManager_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"](folderPath);\n\n      this._loadJson(folderPath).then(function (json) {\n        _this._buildPagesFromJson(json);\n      }, function (error) {\n        return console.log(error);\n      });\n    }\n  }, {\n    key: \"_loadJson\",\n    value: function _loadJson(folderPath) {\n      return new Promise(function (resolve, reject) {\n        var xhr = new XMLHttpRequest();\n        xhr.open(\"GET\", folderPath + \"/\" + defaultManifestFilename);\n        xhr.responseType = \"text\";\n\n        xhr.onload = function () {\n          var text = xhr.response;\n          var json = JSON.parse(text); // CHECK FOR ERRORS\n\n          resolve(json);\n        };\n\n        xhr.onerror = function (error) {\n          reject(error);\n        };\n\n        xhr.send(); // DEAL WITH ERRORS!!!\n      });\n    }\n  }, {\n    key: \"loadFromJSON\",\n    value: function loadFromJSON(json) {\n      this._resourceManager = new _ResourceManager_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"](\"\"); // No folder path...\n\n      this._buildPagesFromJson(json);\n    }\n  }, {\n    key: \"_buildPagesFromJson\",\n    value: function _buildPagesFromJson(json) {\n      var _this2 = this;\n\n      var metadata = json.metadata,\n          readingOrder = json.readingOrder; // CHECK\n\n      var readingProperties = metadata.readingProperties; // CHECK\n\n      var ratio = readingProperties.ratio,\n          fit = readingProperties.fit,\n          overflow = readingProperties.overflow,\n          readingDirection = readingProperties.readingDirection,\n          transitionDuration = readingProperties.transitionDuration;\n      this._transitionDuration = transitionDuration;\n\n      this._player.setRatioConstraint(ratio);\n\n      var storyFit = fit; // AND COMPUTE A DEFAULT ONE BASED ON READING DIRECTION\n\n      var storyOverflow = overflow;\n      this._readingDirection = readingDirection;\n      var currentPage = null;\n      readingOrder.forEach(function (linkObject) {\n        var rel = linkObject.rel,\n            href = linkObject.href,\n            properties = linkObject.properties; // \"type\" and \"width\" I don't care about...\n\n        if (rel === \"cover\") {\n          return;\n        }\n\n        var sliceFit = properties && properties.fit ? properties.fit : storyFit; // CHECK\n\n        var currentOverflow = storyOverflow;\n\n        if (properties) {\n          var _overflow = properties.overflow;\n          currentOverflow = _overflow || storyOverflow; // CHECK\n        }\n\n        if (!currentPage || currentOverflow !== \"scrolled-continuous\") {\n          if (currentPage) {\n            _this2._pagesArray.push(currentPage);\n          }\n\n          currentPage = new _Page_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](_this2._player, readingDirection, currentOverflow);\n\n          if (properties) {\n            currentPage.transition = properties.transition;\n            currentPage.transitionForward = properties.transitionForward;\n            currentPage.transitionBackward = properties.transitionBackward;\n\n            _this2._buildTransitionSequence(properties.transition, sliceFit);\n\n            _this2._buildTransitionSequence(properties.transitionForward, sliceFit);\n\n            _this2._buildTransitionSequence(properties.transitionBackward, sliceFit);\n          }\n        }\n\n        var slice = new _Slice_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](href, sliceFit, _this2._player);\n        currentPage.addSlice(slice);\n\n        _this2._resourceManager.addResource(href);\n\n        if (currentOverflow !== \"paginated\" && properties && properties.layers) {\n          // Layers\n          properties.layers.forEach(function (linkObject) {\n            var href = linkObject.href,\n                properties = linkObject.properties;\n            var speed = properties && properties.speed !== undefined ? properties.speed : 1;\n            var layerSlice = new _LayerSlice_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](href, speed, sliceFit, _this2._player);\n            slice.addLayerSlice(layerSlice);\n\n            _this2._resourceManager.addResource(href);\n          });\n        }\n\n        if (currentOverflow !== \"paginated\" && properties && properties.snapPoints) {\n          currentPage.addSnapPoints(properties.snapPoints);\n        }\n\n        if (!_this2._transitionManager && (properties.transition || properties.transitionForward || properties.transitionForward)) {\n          _this2._transitionManager = new _TransitionManager_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"](_this2._player, _this2._transitionDuration);\n        }\n      });\n\n      this._pagesArray.push(currentPage);\n\n      console.log(currentPage);\n      console.log(this._pagesArray);\n\n      this._resourceManager.loadAllResources().then(function () {\n        _this2._pagesArray.forEach(function (page) {\n          page.finishBuilding();\n        });\n\n        if (_this2._sequenceSlicesArray) {\n          _this2._sequenceSlicesArray.forEach(function (sequenceSlice) {\n            sequenceSlice.build();\n          });\n        }\n\n        _this2._goToPageWithIndex(0); // TEST\n        //this._player.goTo(\"resources/page1res0.png\") // What if you don't find it? goToPageWithIndex(O)\n\n      }, function (error) {\n        return console.log(error);\n      });\n    }\n  }, {\n    key: \"_buildTransitionSequence\",\n    value: function _buildTransitionSequence(transition, sliceFit) {\n      var _this3 = this;\n\n      if (!transition || transition.type !== \"sequence\" || !transition.sequence) {\n        return;\n      }\n\n      if (!this._sequenceSlicesArray) {\n        this._sequenceSlicesArray = [];\n      }\n\n      var sequence = transition.sequence;\n      var duration = transition.duration || this._transitionDuration;\n      var sequenceSlice = new _SequenceSlice_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](sequence, duration, sliceFit, this._player);\n\n      this._sequenceSlicesArray.push(sequenceSlice);\n\n      sequence.forEach(function (linkObject) {\n        _this3._resourceManager.addResource(linkObject.href);\n      });\n      transition.sequenceSlice = sequenceSlice;\n    }\n  }, {\n    key: \"_goToPageWithIndex\",\n    value: function _goToPageWithIndex(index) {\n      var sliceIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n      if (index === this._pageIndex || index < 0 || index > this._pagesArray.length - 1) {\n        return;\n      }\n\n      var isGoingForward = !this._pageIndex || index - this._pageIndex >= 0;\n      this._pageIndex = index;\n      var oldPage = this._currentPage;\n      this._currentPage = this._pagesArray[this._pageIndex];\n\n      this._currentPage.resize();\n\n      if (this._currentPage.overflow !== \"paginated\") {\n        if (sliceIndex !== null) {\n          var progress = this._currentPage.getProgressForSliceIndex(sliceIndex);\n\n          this._currentPage.setProgress(progress);\n        } else {\n          this._currentPage.setProgress(isGoingForward === true ? 0 : 1);\n        }\n      }\n\n      var transition = isGoingForward === true ? this._currentPage.transitionForward || this._currentPage.transition : this._currentPage.transitionBackward || this._currentPage.transition; // REALLY??? Shouldn't it be taken from last linkObject?\n\n      if (!transition || sliceIndex !== null) {\n        this._player.contentContainer.removeChildren();\n\n        this._currentPage.populateContainer(this._player.contentContainer);\n      } else if (this._transitionManager) {\n        this._transitionManager.run(transition, this._currentPage, oldPage);\n      }\n    } // Navigation\n\n  }, {\n    key: \"goForward\",\n    value: function goForward() {\n      if (this._transitionManager && this._transitionManager.isRunning === true) {\n        this._transitionManager.forceToEnd();\n\n        return;\n      }\n\n      var _this$_currentPage = this._currentPage,\n          overflow = _this$_currentPage.overflow,\n          progress = _this$_currentPage.progress;\n\n      if (progress === null || progress === 1) {\n        this._goToNextPage();\n      } else {\n        this._goToNextSnapPoint(); // If there is one!\n\n      }\n    }\n  }, {\n    key: \"goBackward\",\n    value: function goBackward() {\n      if (this._transitionManager && this._transitionManager.isRunning === true) {\n        this._transitionManager.forceToEnd();\n\n        return;\n      }\n\n      var _this$_currentPage2 = this._currentPage,\n          overflow = _this$_currentPage2.overflow,\n          progress = _this$_currentPage2.progress;\n\n      if (progress === null || progress === 0) {\n        this._goToPreviousPage();\n      } else {\n        this._goToPreviousSnapPoint(); // If there is one!\n\n      }\n    }\n  }, {\n    key: \"_goToNextPage\",\n    value: function _goToNextPage() {\n      this._goToPageWithIndex(this._pageIndex + 1);\n    }\n  }, {\n    key: \"_goToPreviousPage\",\n    value: function _goToPreviousPage() {\n      this._goToPageWithIndex(this._pageIndex - 1);\n    }\n  }, {\n    key: \"_goToNextSnapPoint\",\n    value: function _goToNextSnapPoint() {\n      this._currentPage.goToNextSnapPoint();\n    }\n  }, {\n    key: \"_goToPreviousSnapPoint\",\n    value: function _goToPreviousSnapPoint() {\n      this._currentPage.goToPreviousSnapPoint();\n    }\n  }, {\n    key: \"setScrollDelta\",\n    value: function setScrollDelta(scrollDelta) {\n      if (this._transitionManager && this._transitionManager.isRunning === true) {\n        return;\n      }\n\n      this._currentPage.applyScrollDelta(scrollDelta);\n    }\n  }, {\n    key: \"resize\",\n    value: function resize() {\n      if (this._transitionManager) {\n        this._transitionManager.resize();\n      }\n\n      if (this._currentPage) {\n        this._currentPage.resize();\n      }\n    }\n  }, {\n    key: \"goTo\",\n    value: function goTo(href) {\n      var hasFoundHref = false;\n      var linkObjectInfo = {\n        pageIndex: 0,\n        sliceIndex: 0\n      };\n      var i = 0;\n\n      while (i < this._pagesArray.length && hasFoundHref === false) {\n        var slicesArray = this._pagesArray[i].slicesArray;\n        var j = 0;\n\n        while (j < slicesArray.length && hasFoundHref === false) {\n          if (slicesArray[j].href === href) {\n            hasFoundHref = true;\n            linkObjectInfo = {\n              pageIndex: i,\n              sliceIndex: j\n            };\n          }\n\n          j += 1;\n        }\n\n        i += 1;\n      }\n\n      if (hasFoundHref === true) {\n        this._goToPageWithIndex(linkObjectInfo.pageIndex, linkObjectInfo.sliceIndex);\n      }\n    }\n  }]);\n\n  return Story;\n}();\n\n\n\n//# sourceURL=webpack://divinaPlayer/./src/Story.js?");

/***/ }),

/***/ "./src/TransitionManager.js":
/*!**********************************!*\
  !*** ./src/TransitionManager.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return TransitionManager; });\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar defaultTransitionDuration = 2000;\n\nvar TransitionManager =\n/*#__PURE__*/\nfunction () {\n  _createClass(TransitionManager, [{\n    key: \"isRunning\",\n    get: function get() {\n      return this._isRunning;\n    }\n  }, {\n    key: \"oldPage\",\n    get: function get() {\n      return this._oldPage;\n    }\n  }]);\n\n  function TransitionManager(player, transitionDuration) {\n    _classCallCheck(this, TransitionManager);\n\n    this._player = player;\n    this._defaultTransitionDuration = transitionDuration || defaultTransitionDuration;\n    this._contentContainer = this._player.contentContainer;\n    this._oldPageContainer = new PIXI.Container();\n    this._newPageContainer = new PIXI.Container();\n    this._sequenceContainer = new PIXI.Container();\n    this._oldMask = new PIXI.Graphics();\n    this._newMask = new PIXI.Graphics();\n    this._sequenceMask = new PIXI.Graphics();\n    this.resize();\n    this._isRunning = false;\n    this._shouldForceToEnd = false;\n  }\n\n  _createClass(TransitionManager, [{\n    key: \"resize\",\n    value: function resize() {\n      var viewportSize = this._player.viewportSize;\n\n      this._sizeCenteredMask(this._oldMask, viewportSize);\n\n      this._sizeCenteredMask(this._newMask, viewportSize);\n\n      this._sizeCenteredMask(this._sequenceMask, viewportSize);\n\n      this._applyMaskToContainer(this._oldPageContainer, this._oldMask);\n\n      this._applyMaskToContainer(this._newPageContainer, this._newMask);\n\n      this._applyMaskToContainer(this._sequenceContainer, this._sequenceMask);\n\n      if (this._oldPage) {\n        this._oldPage.resize();\n      }\n\n      if (this._sequenceSlice) {\n        this._sequenceSlice.applyFit();\n      }\n    }\n  }, {\n    key: \"_sizeCenteredMask\",\n    value: function _sizeCenteredMask(mask, size) {\n      var width = size.width,\n          height = size.height;\n      mask.clear();\n      mask.beginFill(0x000000);\n      mask.drawRect(-width / 2, -height / 2, width, height);\n      mask.endFill();\n    }\n  }, {\n    key: \"_applyMaskToContainer\",\n    value: function _applyMaskToContainer(container, mask) {\n      container.addChild(mask);\n      container.mask = mask;\n    }\n  }, {\n    key: \"run\",\n    value: function run(transition, newPage, oldPage) {\n      var _this = this;\n\n      this._isRunning = true;\n      this._oldPage = oldPage;\n      var duration = transition.duration || this._defaultTransitionDuration; // Put all current resources in oldPageContainer - yes, even for a sequence!\n\n      this._contentContainer.children.forEach(function (child) {\n        _this._oldPageContainer.addChild(child);\n      });\n\n      this._newPageContainer.removeChildren();\n\n      this._oldPageContainer.position = {\n        x: 0,\n        y: 0\n      };\n      this._newPageContainer.position = {\n        x: 0,\n        y: 0\n      };\n      this._newPageContainer.alpha = 1; // Now populate newPageContainer\n\n      this._newPageContainer.visible = false;\n      newPage.populateContainer(this._newPageContainer);\n\n      if (transition.type === \"sequence\") {\n        if (!transition.sequence || transition.sequence.length === 0) {\n          return;\n        }\n\n        this._oldPageContainer.removeChildren(); // Will actually hold the animated sprite!\n\n\n        this._contentContainer.addChild(this._newPageContainer);\n\n        this._contentContainer.addChild(this._oldPageContainer);\n\n        this._contentContainer.addChild(this._sequenceContainer);\n\n        if (transition.sequenceSlice && transition.sequenceSlice.sprite) {\n          this._sequenceSlice = transition.sequenceSlice;\n\n          this._sequenceSlice.applyFit();\n\n          this._sequenceContainer.addChild(this._sequenceSlice.sprite);\n        }\n      } else if (transition.type === \"slide-out\") {\n        this._contentContainer.addChild(this._newPageContainer);\n\n        this._contentContainer.addChild(this._oldPageContainer);\n      } else {\n        this._contentContainer.addChild(this._oldPageContainer);\n\n        this._contentContainer.addChild(this._newPageContainer);\n      }\n\n      this._applyMaskToContainer(this._oldPageContainer, this._oldMask); // ???\n\n\n      this._applyMaskToContainer(this._newPageContainer, this._newMask);\n\n      var transitionData = _objectSpread({}, transition, {\n        duration: duration,\n        startTime: Date.now()\n      });\n\n      if (this._sequenceSlice) {\n        this._sequenceSlice.sprite.play();\n      }\n\n      this._transitionLoop(transitionData);\n    }\n  }, {\n    key: \"_transitionLoop\",\n    value: function _transitionLoop(transitionData) {\n      var type = transitionData.type,\n          direction = transitionData.direction,\n          duration = transitionData.duration,\n          startTime = transitionData.startTime;\n      var elapsedTime = Date.now() - startTime;\n\n      if (this._shouldForceToEnd === true || elapsedTime >= duration) {\n        this._endTransition();\n      } else {\n        var percent = elapsedTime / duration;\n        var _this$_player$viewpor = this._player.viewportSize,\n            width = _this$_player$viewpor.width,\n            height = _this$_player$viewpor.height;\n\n        if (type === \"dissolve\") {\n          this._newPageContainer.alpha = percent;\n        }\n\n        if (type === \"slide-in\" || type === \"push\") {\n          switch (direction) {\n            case \"ltr\":\n              this._newPageContainer.position.x = (percent - 1) * width;\n              break;\n\n            case \"rtl\":\n              this._newPageContainer.position.x = (1 - percent) * width;\n              break;\n\n            case \"ttb\":\n              this._newPageContainer.position.y = (percent - 1) * height;\n              break;\n\n            case \"btt\":\n              this._newPageContainer.position.y = (1 - percent) * height;\n              break;\n\n            default:\n              break;\n          }\n        }\n\n        if (type === \"slide-out\" || type === \"push\") {\n          switch (direction) {\n            case \"ltr\":\n              this._oldPageContainer.position.x = percent * width;\n              break;\n\n            case \"rtl\":\n              this._oldPageContainer.position.x = -percent * width;\n              break;\n\n            case \"ttb\":\n              this._oldPageContainer.position.y = percent * height;\n              break;\n\n            case \"btt\":\n              this._oldPageContainer.position.y = -percent * height;\n              break;\n\n            default:\n              break;\n          }\n        }\n\n        this._newPageContainer.visible = true;\n        requestAnimationFrame(this._transitionLoop.bind(this, transitionData));\n      }\n    }\n  }, {\n    key: \"_endTransition\",\n    value: function _endTransition() {\n      var _this2 = this;\n\n      this._contentContainer.removeChildren();\n\n      this._oldPageContainer.removeChildren();\n\n      this._newPageContainer.children.forEach(function (child) {\n        _this2._contentContainer.addChild(child);\n      });\n\n      this._sequenceContainer.removeChildren();\n\n      if (this._sequenceSlice) {\n        this._sequenceSlice.sprite.gotoAndStop(0);\n\n        this._sequenceSlice = null;\n      }\n\n      this._oldPage = null;\n      this._isRunning = false;\n      this._shouldForceToEnd = false;\n    }\n  }, {\n    key: \"forceToEnd\",\n    value: function forceToEnd() {\n      this._shouldForceToEnd = true;\n    }\n  }]);\n\n  return TransitionManager;\n}();\n\n\n\n//# sourceURL=webpack://divinaPlayer/./src/TransitionManager.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Player_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Player.js */ \"./src/Player.js\");\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (_Player_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n//# sourceURL=webpack://divinaPlayer/./src/index.js?");

/***/ })

/******/ })["default"];